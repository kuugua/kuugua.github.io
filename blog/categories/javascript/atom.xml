<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 因上努力，果上随缘]]></title>
  <link href="http://kuugua.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://kuugua.github.io/"/>
  <updated>2013-12-24T19:47:48+08:00</updated>
  <id>http://kuugua.github.io/</id>
  <author>
    <name><![CDATA[kuugua]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【原创】javascript中的函数(一)：调用方式与this变量]]></title>
    <link href="http://kuugua.github.io/blog/2013/10/16/javascript-function-this/"/>
    <updated>2013-10-16T21:37:00+08:00</updated>
    <id>http://kuugua.github.io/blog/2013/10/16/javascript-function-this</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="http://farm8.staticflickr.com/7345/9770973423_b7b913d727_c.jpg">http://farm8.staticflickr.com/7345/9770973423_b7b913d727_c.jpg</a>" title="by  Chic*ka" ></p>

<p>最近看道大师的 javascript：The Good part一书中谈道在javascript中函数的调用的四种方式，今天就来说说这四种不同方式下的this变量的含义。以下代码建议在chrome下运行。</p>

<h4>1. 函数的方法调用模式</h4>

<p>当function作为对象的属性调用时，我们称之为方法。看以下代码结果。
```javascript
var myObject = {</p>

<pre><code>value: 0,
increment: function(inc){
    // console.log(typeof inc);  //返回表示数据类型的字符串。
    // console.log(typeof inc === 'number') //inc 如果是number类型，则输出true；
    console.log(this);//谁调用this 指向谁。输出myObject对象
    this.value += typeof inc === 'number' ? inc : 1;
}
</code></pre>

<p>};
myObject.increment();
console.log(myObject.value); //1
myObject.increment(2);
console.log(myObject.value); //3
myObject.increment(&lsquo;0&rsquo;);
console.log(myObject.value); //4
```
可见，在函数作为对象的属性时，被调用时this指向这个对象。</p>

<h4>2. 函数的函数调用模式</h4>

<p>当函数并非一个对象的属性时，那它就当做一个函数来调用。
```javascript
myObject.double = function(){</p>

<pre><code>console.log(this); //myObject
console.log("outter function's this: " + this); //myObject
var helper = function(){
    //绑定到了全局的对象window；
    console.log("inner function's this: " + this); //window
}
helper();
</code></pre>

<p>};
myObject.double();
<code>
我们为myObject增加一个double方法，并且在double方法中定义了一个helper函数，并调用它。我们可以可以看到这个时候，第一个输出的this指向myObject，原理跟第一个一样。然而，helper函数里面的this却指向了window全局对象。正如道大师所说这是javascript设计中的一个错误。为了能让内嵌的函数能访问包裹它的函数的上下文，我们可以如下设计。
</code>javascript
//利用js函数闭包可以访问上一层的函数的上下文的特性。
//把对象本身赋值给变量that。这样就实现了对外层函数的操作。
myObject.double = function(){</p>

<pre><code>var  that = this;
var helper = function(){
    console.log(that.value);
    that.value = that.value + 1;
    console.log(that.value);
}
helper();
</code></pre>

<p>};
myObject.double();
```
我们习惯上把包裹函数的this对象赋值给that，利用javascript闭包的特性，就可以使用内嵌函数访问包裹函数的上下文。这个特性经常会用到。</p>

<h4>3. 函数的构造器调用模式</h4>

<p>如果一个函数的创建是为了让new调用，那么这个函数成为构造器，当用new调用时，会创建一个新对象，并且这个对默认链接到这个构造器的prototype属性的对象上。见如下代码：
```javascript
var Quo = function(string){</p>

<pre><code>console.log("inner constructor this: ");
console.log(this);
this.status = string;
console.log(this);
</code></pre>

<p>}</p>

<p>//给所有从Quo构造的对象添加get_status方法。
Quo.prototype.get_status = function(){</p>

<pre><code>console.log("inner get_status this: ");
console.log(this);
return this.status;
</code></pre>

<p>};
var myQuo = new Quo(&ldquo;confused..&rdquo;);
console.log(&ldquo;myQuo.get_status: &rdquo; + myQuo.get_status());
```
这个时候构造器内的this指向了新创建的对象。</p>

<h4>4. 函数的apply调用模式</h4>

<p>apply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值，apply方法接收两个参数，第一个是要绑定给this的值，第二个就是一个参数数组；
```javascript
var status_Object = {</p>

<pre><code>status: 'A-OK'
</code></pre>

<p>};</p>

<p>//status_Object 并没有继承自Quo.prototype，但我们可以在status_Object
//调用get_status方法。
var status = Quo.prototype.get_status.apply(status_Object);
console.log(status);
```
结合第三种调用方式中的代码，可以看出，因为get_status方法的参数为空，所以我们只传入了status_Object，从输出（get_status方法内的输出）可见this指向了status_Object。但当apply()的参数为空时，默认调用全局对象。</p>
]]></content>
  </entry>
  
</feed>
